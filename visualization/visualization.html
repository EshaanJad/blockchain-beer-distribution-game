<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beer Distribution Game Data Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 1400px; /* Increased max-width for better layout */
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chart-container {
            margin-bottom: 60px; /* Increased from 40px */
            width: 100%;
            max-width: 1200px; /* Increased max-width for charts */
            padding-bottom: 40px; /* Add padding at the bottom to prevent cropping */
        }
        .main-chart-item {
            min-height: 600px; /* Increased from 500px */
            position: relative; /* Add positioning context */
        }
        .main-charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 60px; /* Increased from 40px for better separation */
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
            margin-bottom: 40px; /* Add bottom margin */
        }
        .line {
            fill: none;
            stroke-width: 2;
        }
        .grid line {
            stroke: lightgrey;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }
        .grid path {
            stroke-width: 0;
        }
        .legend {
            font-size: 12px;
        }
        h1, h2 {
            text-align: center;
            width: 100%;
        }
        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 20px;
            width: 100%;
        }
        select, button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        #refreshData {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        #refreshData:hover {
            background-color: #45a049;
        }
        
        .axis-label {
            font-size: 12px;
            text-anchor: middle;
        }
        svg {
            display: block;
            width: 100%;
            height: auto;
            overflow: visible; /* Allow content to overflow boundaries */
        }
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 200px;
        }
        
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 3px;
        }
        
        .tooltip-value {
            margin-top: 3px;
        }
        
        .tooltip-phase {
            font-style: italic;
            color: #aaa;
            font-size: 11px;
            margin-top: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
            cursor: pointer;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 5px;
        }
        
        .legend-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
            padding: 5px 10px;
            background: #f9f9f9;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Beer Distribution Game Visualization</h1>
    <h3 style="text-align: center; margin-top: -10px; color: #555; font-style: italic; font-weight: normal;">Full Simulations (23+ Periods)</h3>

    <div class="controls">
        <select id="roleSelect">
            <option value="all">All Roles</option>
            <option value="retailer">Retailer</option>
            <option value="wholesaler">Wholesaler</option>
            <option value="distributor">Distributor</option>
            <option value="factory">Factory</option>
        </select>
        <select id="datasetSelect">
            <option value="forecasted_52">Forecasted Crocs (52 periods through 2038)</option>
            <option value="forecasted_two_one_delay_52">Forecasted Crocs Two Week Order + One Week Ship Delay (52 periods)</option>
            <option value="triple_hybrid_23">Triple Hybrid Simulation (23 periods)</option>
            <option value="extended_hybrid_23">Extended Hybrid Simulation (23 periods)</option>
            <option value="hybrid_23">Hybrid Simulation (23 periods)</option>
            <option value="crocs_two_week_delay_23">Crocs Two Week Delay (23 periods)</option>
            <option value="crocs_two_one_delay_23">Crocs Two Week Order + One Week Ship Delay (23 periods)</option>
            <option value="crocs_one_two_delay_23">Crocs One Week Order + Two Week Ship Delay (23 periods)</option>
            <option value="crocs_zero_delay_23">Crocs Zero Delay (23 periods)</option>
            <option value="crocs_23">Crocs (23 periods)</option>
            <option value="crocs_30">Crocs (30 periods)</option>
            <option value="random">Random Simulation</option>
            <option value="alpha_tuning">Alpha Tuning Results</option>
        </select>
        <button id="refreshData">Refresh Data</button>
    </div>

    <!-- Loading indicator -->
    <div id="loadingIndicator" style="text-align: center; padding: 20px;">
        <p>Loading simulation data... Please wait.</p>
    </div>

    <!-- Error message container -->
    <div id="errorContainer" style="display: none; color: red; text-align: center; padding: 20px; border: 1px solid #ffcccc; margin: 20px; background-color: #fff5f5;">
        <h3>Error Loading Data</h3>
        <p id="errorMessage">Unable to load simulation data. Please check if the JSON files exist in the correct location.</p>
    </div>

    <div id="visualization-content" style="display: none;">
        <div id="dataInfo" style="text-align: center; margin-bottom: 10px; font-size: 12px; color: #666;">
            <span id="lastUpdated"></span>
        </div>
        
        <!-- Game Settings and Parameters Panel -->
        <div id="gameSettings" style="margin: 10px auto 20px auto; padding: 15px; background-color: #f8f9fa; border-radius: 8px; max-width: 1100px; border: 1px solid #e9ecef;">
            <h3 style="margin-top: 0; margin-bottom: 15px; color: #345; font-size: 18px;">Simulation Settings & Parameters</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                <div>
                    <h4 style="margin-top: 0; margin-bottom: 8px; font-size: 15px;">General Parameters</h4>
                    <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Simulation Type:</td>
                            <td style="padding: 5px;"><span id="simType">-</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Periods:</td>
                            <td style="padding: 5px;"><span id="simPeriods">-</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Delay Pattern:</td>
                            <td style="padding: 5px;"><span id="delayPattern">-</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Ordering Policy:</td>
                            <td style="padding: 5px;"><span id="orderingPolicy">-</span></td>
                        </tr>
                    </table>
                </div>
                <div>
                    <h4 style="margin-top: 0; margin-bottom: 8px; font-size: 15px;">Cost Parameters</h4>
                    <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Holding Cost:</td>
                            <td style="padding: 5px;"><span id="holdingCost">$1 per unit per period</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Backlog Cost:</td>
                            <td style="padding: 5px;"><span id="backlogCost">$2 per unit per period</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Safety Stock:</td>
                            <td style="padding: 5px;"><span id="safetyStock">-</span></td>
                        </tr>
                    </table>
                </div>
                <div>
                    <h4 style="margin-top: 0; margin-bottom: 8px; font-size: 15px;">Initial Conditions</h4>
                    <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Initial Inventory:</td>
                            <td style="padding: 5px;"><span id="initialInventory">-</span></td>
                        </tr>
                        <tr>
                            <td style="padding: 5px; font-weight: bold;">Initial Backlog:</td>
                            <td style="padding: 5px;"><span id="initialBacklog">-</span></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div style="margin-top: 10px; border-top: 1px solid #e9ecef; padding-top: 10px;">
                <h4 style="margin-top: 0; margin-bottom: 8px; font-size: 15px;">Scenario Difference</h4>
                <p style="margin: 0; font-size: 14px;"><span id="scenarioDifference">In the <strong>Blockchain</strong> scenario, upstream players have visibility into end-customer demand and downstream inventory positions. In the <strong>Traditional</strong> scenario, players only see orders from their immediate downstream partner.</span></p>
            </div>
        </div>
        
        <div id="simulationInfo" style="margin: 10px auto 20px auto; padding: 10px; background-color: #f0f7ff; border-radius: 8px; max-width: 1100px; border-left: 4px solid #2c88d9;">
            <p style="margin: 0; font-size: 14px;"><strong>Note:</strong> This visualization shows only full simulation runs (23 periods or more). 
            Shorter simulation runs have been excluded to ensure complete analysis of the beer distribution game dynamics.</p>
        </div>
        
        <div id="simulationDescription" style="margin: 10px auto 30px auto; padding: 15px; background-color: #f8f9fa; border-radius: 8px; max-width: 1100px; display: none;">
            <h3 style="margin-top: 0; color: #345;">Hybrid Simulation Description</h3>
            <p>This simulation uses the following approach:</p>
            <ul>
                <li><strong>Retailer:</strong> Uses fixed order quantities from historical data (CSV)</li>
                <li><strong>Upstream Players:</strong> Use an algorithmic base-stock policy</li>
                <li><strong>Blockchain Visibility:</strong> In the blockchain scenario, upstream players have visibility into end-customer demand and downstream inventory positions</li>
                <li><strong>Traditional Scenario:</strong> Players only see orders from their immediate downstream partner</li>
            </ul>
            <p><strong>Key Insight:</strong> The blockchain scenario demonstrates how end-to-end visibility creates value even when some players (the retailer) continue to use fixed ordering patterns.</p>
        </div>
        
        <div id="extendedSimulationDescription" style="margin: 10px auto 30px auto; padding: 15px; background-color: #f8f9fa; border-radius: 8px; max-width: 1100px; display: none;">
            <h3 style="margin-top: 0; color: #345;">Extended Hybrid Simulation Description</h3>
            <p>This simulation uses the following approach:</p>
            <ul>
                <li><strong>Fixed Order Data:</strong> Customer demand, Retailer orders, and Wholesaler orders all use fixed data from CSV</li>
                <li><strong>Algorithmic Players:</strong> Only the Distributor and Factory use algorithmic base-stock policies</li>
                <li><strong>Blockchain Visibility:</strong> In the blockchain scenario, algorithmic players have visibility into end-customer demand and inventory positions</li>
                <li><strong>Traditional Scenario:</strong> Players only see orders from their immediate downstream partner</li>
            </ul>
            <p><strong>Key Insight:</strong> This simulation tests whether blockchain visibility creates value even with more limited adoption (only 2 players use algorithmic policies).</p>
        </div>
        
        <div id="tripleSimulationDescription" style="margin: 10px auto 30px auto; padding: 15px; background-color: #f8f9fa; border-radius: 8px; max-width: 1100px; display: none;">
            <h3 style="margin-top: 0; color: #345;">Triple Hybrid Simulation Description</h3>
            <p>This simulation uses the following approach:</p>
            <ul>
                <li><strong>Fixed Order Data:</strong> Customer demand, Retailer orders, Wholesaler orders, and Distributor orders all use fixed data from CSV</li>
                <li><strong>Algorithmic Players:</strong> Only the Factory uses algorithmic base-stock policy</li>
                <li><strong>Blockchain Visibility:</strong> In the blockchain scenario, the Factory has visibility into end-customer demand and inventory positions</li>
                <li><strong>Traditional Scenario:</strong> The Factory only sees orders from its immediate downstream partner (Distributor)</li>
            </ul>
            <p><strong>Key Insight:</strong> This simulation tests whether blockchain visibility creates value even with minimal adoption (only 1 player uses algorithmic policy).</p>
        </div>
        
        <div id="forecastedSimulationDescription" style="margin: 10px auto 30px auto; padding: 15px; background-color: #f8f9fa; border-radius: 8px; max-width: 1100px; display: none;">
            <h3 style="margin-top: 0; color: #345;">Forecasted Crocs Simulation Description</h3>
            <p>This simulation uses the following approach:</p>
            <ul>
                <li><strong>Extended Time Horizon:</strong> Uses forecasted demand data through 2038 (52 periods total)</li>
                <li><strong>Full Algorithmic Supply Chain:</strong> All supply chain players use algorithmic base-stock policies</li>
                <li><strong>Blockchain Visibility:</strong> In the blockchain scenario, all players have visibility into end-customer demand and inventory positions</li>
                <li><strong>Traditional Scenario:</strong> Players only see orders from their immediate downstream partner</li>
                <li><strong>Delay Variants:</strong> Multiple configurations testing different order delays (0, 1, or 2 weeks) and shipping delays (1 or 2 weeks)</li>
            </ul>
            <p><strong>Key Insight:</strong> This simulation tests whether blockchain visibility's value persists over a longer time horizon with forecasted future demand patterns and under different delay configurations.</p>
        </div>
        
        <div id="costComparison" class="chart-container">
            <h2>Total Supply Chain Cost Comparison</h2>
            <div id="costChart"></div>
        </div>

        <!-- Grid container for the four main charts -->
        <div class="main-charts-grid">
            <div id="ordersVisualization" class="chart-container main-chart-item">
                <h2 id="ordersChartTitle">Order Quantities Over Time</h2>
                <div id="ordersChart"></div>
            </div>
            <div id="inventoryVisualization" class="chart-container main-chart-item">
                <h2 id="inventoryChartTitle">Inventory Levels Over Time</h2>
                <div id="inventoryChart"></div>
            </div>
            <div id="backlogVisualization" class="chart-container main-chart-item">
                <h2 id="backlogChartTitle">Backlog Quantities Over Time</h2>
                <div id="backlogChart"></div>
            </div>
            <div id="costsVisualization" class="chart-container main-chart-item">
                <h2 id="costsChartTitle">Weekly Costs Over Time</h2>
                <div id="costsChart"></div>
            </div>
        </div>

        <!-- Add this new container for alpha tuning visualization, initially hidden -->
        <div id="alphaTuningContainer" class="chart-container" style="display: none;">
            <h2>Alpha Tuning Results Visualization</h2>
            <p style="text-align: center; margin-bottom: 20px;">This visualization shows how different alpha and threshold values affect the total cost in the supply chain simulation.</p>
            
            <div style="background-color: #f0f7ff; padding: 15px; margin-bottom: 20px; border-radius: 8px; border-left: 4px solid #2c88d9; max-width: 1100px; margin-left: auto; margin-right: auto;">
                <h4 style="margin-top: 0; color: #345;">Parameter Explanation</h4>
                <ul style="margin-bottom: 0;">
                    <li><strong>Alpha (α):</strong> The smoothing factor used in the exponential smoothing forecast algorithm. Higher values give more weight to recent observations, making the forecast more responsive to recent changes but potentially more volatile.</li>
                    <li><strong>Threshold High:</strong> A multiplier applied to the standard deviation when calculating safety stock. Higher threshold values result in more safety stock, reducing stockouts but increasing holding costs.</li>
                    <li><strong>Total Cost:</strong> The sum of inventory holding costs and backlog penalty costs across the entire supply chain for the simulation period.</li>
                </ul>
            </div>
            
            <div style="display: flex; justify-content: space-between; max-width: 1100px; margin: 0 auto;">
                <div style="flex: 1;">
                    <h3 style="text-align: center;">Heatmap of Total Cost</h3>
                    <div id="alphaTuningHeatmap" style="height: 400px;"></div>
                </div>
                <div style="flex: 1;">
                    <h3 style="text-align: center;">Alpha vs Cost</h3>
                    <div id="alphaCostChart" style="height: 400px;"></div>
                </div>
            </div>
            
            <div style="margin-top: 40px; max-width: 1100px; margin: 40px auto 0;">
                <h3 style="text-align: center;">Threshold vs Cost</h3>
                <div id="thresholdCostChart" style="height: 400px;"></div>
            </div>
            
            <div style="margin-top: 40px; max-width: 1100px; margin: 40px auto 0;">
                <h3 style="text-align: center;">Alpha Tuning Data</h3>
                <table id="alphaTuningTable" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <thead>
                        <tr style="background-color: #f2f2f2;">
                            <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Threshold High</th>
                            <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Min Alpha</th>
                            <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Total Cost</th>
                        </tr>
                    </thead>
                    <tbody id="alphaTuningTableBody">
                        <!-- Table rows will be populated dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let blockchainData, traditionalData;
        
        // Load the default dataset on page load
        loadDataset('forecasted_52');
        
        // Function to load a dataset based on selection
        function loadDataset(datasetKey) {
            // Show loading indicator, hide content
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('visualization-content').style.display = 'none';
            document.getElementById('errorContainer').style.display = 'none';
            
            // Hide alpha tuning container by default
            document.getElementById('alphaTuningContainer').style.display = 'none';
            
            // Handle showing/hiding simulation descriptions
            const hybridDescriptionEl = document.getElementById('simulationDescription');
            const extendedHybridDescriptionEl = document.getElementById('extendedSimulationDescription');
            const tripleHybridDescriptionEl = document.getElementById('tripleSimulationDescription');
            const forecastedSimulationDescriptionEl = document.getElementById('forecastedSimulationDescription');
            
            if (datasetKey === 'hybrid_23') {
                hybridDescriptionEl.style.display = 'block';
                extendedHybridDescriptionEl.style.display = 'none';
                tripleHybridDescriptionEl.style.display = 'none';
                forecastedSimulationDescriptionEl.style.display = 'none';
            } else if (datasetKey === 'extended_hybrid_23') {
                hybridDescriptionEl.style.display = 'none';
                extendedHybridDescriptionEl.style.display = 'block';
                tripleHybridDescriptionEl.style.display = 'none';
                forecastedSimulationDescriptionEl.style.display = 'none';
            } else if (datasetKey === 'triple_hybrid_23') {
                hybridDescriptionEl.style.display = 'none';
                extendedHybridDescriptionEl.style.display = 'none';
                tripleHybridDescriptionEl.style.display = 'block';
                forecastedSimulationDescriptionEl.style.display = 'none';
            } else if (datasetKey === 'forecasted_52' || datasetKey === 'forecasted_two_one_delay_52') {
                hybridDescriptionEl.style.display = 'none';
                extendedHybridDescriptionEl.style.display = 'none';
                tripleHybridDescriptionEl.style.display = 'none';
                forecastedSimulationDescriptionEl.style.display = 'block';
            } else {
                hybridDescriptionEl.style.display = 'none';
                extendedHybridDescriptionEl.style.display = 'none';
                tripleHybridDescriptionEl.style.display = 'none';
                forecastedSimulationDescriptionEl.style.display = 'none';
            }
            
            // Special handling for alpha tuning data
            if (datasetKey === 'alpha_tuning') {
                loadAlphaTuningData();
                return;
            } else {
                // Show the main charts for regular simulations
                document.querySelectorAll('.main-charts-grid, #costComparison').forEach(el => {
                    el.style.display = 'block';
                });
            }
            
            // Determine file paths based on dataset selection
            let blockchainPath, traditionalPath;
            
            switch(datasetKey) {
                case 'forecasted_52':
                    blockchainPath = './data/simulations/non-sterman/forecasted/data_blockchain_forecasted_crocs_52_periods.json';
                    traditionalPath = './data/simulations/non-sterman/forecasted/data_traditional_forecasted_crocs_52_periods.json';
                    break;
                case 'forecasted_two_one_delay_52':
                    blockchainPath = './data/simulations/non-sterman/delay_variants/data_blockchain_forecasted_crocs_two_one_delay_52_periods.json';
                    traditionalPath = './data/simulations/non-sterman/delay_variants/data_traditional_forecasted_crocs_two_one_delay_52_periods.json';
                    break;
                case 'triple_hybrid_23':
                    blockchainPath = './data/simulations/non-sterman/hybrid/data_blockchain_triple_hybrid_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/hybrid/data_traditional_triple_hybrid_23_periods.json';
                    break;
                case 'extended_hybrid_23':
                    blockchainPath = './data/simulations/non-sterman/hybrid/data_blockchain_extended_hybrid_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/hybrid/data_traditional_extended_hybrid_23_periods.json';
                    break;
                case 'hybrid_23':
                    blockchainPath = './data/simulations/non-sterman/hybrid/data_blockchain_hybrid_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/hybrid/data_traditional_hybrid_23_periods.json';
                    break;
                case 'crocs_two_week_delay_23':
                    blockchainPath = './data/simulations/non-sterman/delay_variants/data_blockchain_crocs_two_week_delay_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/delay_variants/data_traditional_crocs_two_week_delay_23_periods.json';
                    break;
                case 'crocs_two_one_delay_23':
                    blockchainPath = './data/simulations/non-sterman/delay_variants/data_blockchain_crocs_two_one_delay_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/delay_variants/data_traditional_crocs_two_one_delay_23_periods.json';
                    break;
                case 'crocs_one_two_delay_23':
                    blockchainPath = './data/simulations/non-sterman/delay_variants/data_blockchain_crocs_one_two_delay_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/delay_variants/data_traditional_crocs_one_two_delay_23_periods.json';
                    break;
                case 'crocs_zero_delay_23':
                    blockchainPath = './data/simulations/non-sterman/delay_variants/data_blockchain_crocs_zero_delay_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/delay_variants/data_traditional_crocs_zero_delay_23_periods.json';
                    break;
                case 'crocs_23':
                    blockchainPath = './data/simulations/non-sterman/standard/data_blockchain_crocs_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/standard/data_traditional_crocs_23_periods.json';
                    break;
                case 'crocs_30':
                    blockchainPath = './data/simulations/non-sterman/standard/data_blockchain_crocs_30_periods.json';
                    traditionalPath = './data/simulations/non-sterman/standard/data_traditional_crocs_30_periods.json';
                    break;
                case 'random':
                    blockchainPath = './data/simulations/non-sterman/random/data_blockchain_random.json';
                    traditionalPath = './data/simulations/non-sterman/random/data_traditional_random.json';
                    break;
                default:
                    blockchainPath = './data/simulations/non-sterman/standard/data_blockchain_crocs_23_periods.json';
                    traditionalPath = './data/simulations/non-sterman/standard/data_traditional_crocs_23_periods.json';
            }
            
            // Add cache-busting parameter
            blockchainPath += '?v=' + new Date().getTime();
            traditionalPath += '?v=' + new Date().getTime();
            
            // Load JSON data files
            Promise.all([
                d3.json(blockchainPath),
                d3.json(traditionalPath)
            ]).then(function(data) {
                blockchainData = data[0];
                traditionalData = data[1];
                
                console.log("Successfully loaded data:", datasetKey);
                console.log("Blockchain data:", blockchainData);
                console.log("Traditional data:", traditionalData);
                
                // Update last loaded timestamp
                updateDataTimestamp();
                
                // Update simulation settings panel
                updateSimulationSettings(datasetKey, blockchainData, traditionalData);
                
                // Sample data for retailer to inspect structure
                if (blockchainData && blockchainData.retailer && blockchainData.retailer.length > 0) {
                    console.log("Sample retailer data (blockchain):", blockchainData.retailer[0]);
                }
                
                // Hide loading indicator, show content
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('visualization-content').style.display = 'block';
                
                // Draw all charts once data is loaded
                drawAllCharts();
                
            }).catch(function(error) {
                console.error('Error loading data:', error);
                // Hide loading, show error
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('errorContainer').style.display = 'block';
                document.getElementById('errorMessage').textContent = 
                    'Error loading data: ' + error.message + '. Please check if the JSON files exist and the server is running.';
            });
        }
        
        // Set up event listeners once the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listener for role select
            d3.select('#roleSelect').on('change', drawAllCharts);
            
            // Set up event listener for dataset select
            d3.select('#datasetSelect').on('change', function() {
                const selectedDataset = d3.select(this).property('value');
                loadDataset(selectedDataset);
            });
            
            // Setup refresh button
            d3.select('#refreshData').on('click', function() {
                const selectedDataset = d3.select('#datasetSelect').property('value');
                loadDataset(selectedDataset);
            });
        });

        function drawAllCharts() {
            drawCostComparison();
            drawMainChart('orders', 'ordersChart');
            drawMainChart('inventory', 'inventoryChart');
            drawMainChart('backlog', 'backlogChart');
            drawMainChart('costs', 'costsChart');
            updateTitles();
        }

        // Update the timestamp display
        function updateDataTimestamp() {
            const now = new Date();
            const formattedTime = now.toLocaleTimeString() + ' on ' + now.toLocaleDateString();
            document.getElementById('lastUpdated').textContent = 'Data last loaded: ' + formattedTime;
        }

        // Get the current role filter
        function getCurrentRoleFilter() {
            return d3.select('#roleSelect').property('value');
        }

        // Get chart title based on chart type
        function getChartTitle(chartType) {
            const roleFilter = getCurrentRoleFilter();
            const roleSuffix = roleFilter !== 'all' ? ` (${capitalizeFirstLetter(roleFilter)})` : '';
            
            switch(chartType) {
                case 'orders': 
                    return (roleFilter === 'factory') ? 
                        `Production Quantities Over Time${roleSuffix}` : 
                        `Order Quantities Over Time${roleSuffix}`;
                case 'inventory': return `Inventory Levels Over Time${roleSuffix}`;
                case 'backlog': return `Backlog Quantities Over Time${roleSuffix}`;
                case 'costs': return `Weekly Costs Over Time${roleSuffix}`;
                default: return `Data Over Time${roleSuffix}`;
            }
        }

        function updateTitles() {
            document.getElementById('ordersChartTitle').textContent = 'Order Quantities Over Time';
            document.getElementById('inventoryChartTitle').textContent = 'Inventory Levels Over Time';
            document.getElementById('backlogChartTitle').textContent = 'Backlog Quantities Over Time';
            document.getElementById('costsChartTitle').textContent = 'Weekly Costs Over Time';
            
            const roleFilter = d3.select('#roleSelect').property('value');
            const ordersTitle = document.getElementById('ordersChartTitle');
            if (roleFilter === 'factory') {
                ordersTitle.textContent = 'Production Quantities Over Time';
            } else {
                ordersTitle.textContent = 'Order Quantities Over Time';
            }
        }

        function drawCostComparison() {
            // Check if we have both datasets
            if (!blockchainData || !traditionalData) {
                d3.select('#costChart').text("Cost comparison requires both traditional and blockchain data.");
                return;
            }

            // Clear previous chart
            d3.select('#costChart').html("");

            // Chart dimensions
            const margin = { top: 50, right: 150, bottom: 80, left: 80 };
            const width = 800 - margin.left - margin.right;
            const height = 550 - margin.top - margin.bottom;

            const svg = d3.select('#costChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .style('overflow', 'visible')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate cumulative costs for both datasets
            const blockchainCumulativeCosts = calculateCumulative(blockchainData);
            const traditionalCumulativeCosts = calculateCumulative(traditionalData);

            if (blockchainCumulativeCosts.length === 0 || traditionalCumulativeCosts.length === 0) {
                console.error("Cost Comparison: Failed to extract cost data.");
                d3.select('#costChart').text("Error processing cost data.");
                return;
            }

            // Scales
            const x = d3.scaleLinear()
                .domain([0, Math.max(blockchainCumulativeCosts.length - 1, traditionalCumulativeCosts.length - 1)])
                .range([0, width]);

            const maxCost = Math.max(
                d3.max(blockchainCumulativeCosts, d => d.value) || 0,
                d3.max(traditionalCumulativeCosts, d => d.value) || 0
            );
            const y = d3.scaleLinear()
                .domain([0, maxCost * 1.15])
                .range([height, 0]);

            // Add title
            svg.append('text')
                .attr('class', 'chart-title')
                .attr('x', width / 2)
                .attr('y', -20)
                .text('Cumulative Supply Chain Cost Comparison');

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(Math.min(blockchainCumulativeCosts.length, 10)));

            svg.append('g')
                .call(d3.axisLeft(y));

            // Line generator
            const line = d3.line()
                .x(d => x(d.week))
                .y(d => y(d.value));

            // Add blockchain line
            svg.append('path')
                .datum(blockchainCumulativeCosts)
                .attr('class', 'line')
                .attr('d', line)
                .style('stroke', 'steelblue')
                .style('fill', 'none')
                .style('stroke-width', 2);

            // Add traditional line
            svg.append('path')
                .datum(traditionalCumulativeCosts)
                .attr('class', 'line')
                .attr('d', line)
                .style('stroke', 'red')
                .style('fill', 'none')
                .style('stroke-width', 2);

            // Legend
            const legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width + 20}, 20)`);

            legend.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 20).attr('y2', 0).style('stroke', 'steelblue').style('stroke-width', 2);
            legend.append('text').attr('x', 25).attr('y', 5).text('Blockchain');

            legend.append('line').attr('x1', 0).attr('y1', 25).attr('x2', 20).attr('y2', 25).style('stroke', 'red').style('stroke-width', 2);
            legend.append('text').attr('x', 25).attr('y', 30).text('Traditional');

            // Final costs
            const finalBlockchainCost = blockchainCumulativeCosts.length > 0 ? blockchainCumulativeCosts[blockchainCumulativeCosts.length - 1].value : 0;
            const finalTraditionalCost = traditionalCumulativeCosts.length > 0 ? traditionalCumulativeCosts[traditionalCumulativeCosts.length - 1].value : 0;
            const costReduction = finalTraditionalCost - finalBlockchainCost;
            const costReductionPercent = finalTraditionalCost > 0 ? (costReduction / finalTraditionalCost * 100) : 0;

            const summaryText = svg.append('g')
                .attr('transform', `translate(${width / 2}, ${height + 40})`);

            summaryText.append('text')
                .attr('text-anchor', 'middle')
                .text(`Cost reduction with blockchain: ${costReduction.toFixed(2)} (${costReductionPercent.toFixed(2)}%)`);
            
            // Add detailed breakdown for hybrid simulations
            if (d3.select('#datasetSelect').property('value') === 'hybrid_23') {
                summaryText.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('y', 20)
                    .text(`Traditional cost: ${finalTraditionalCost.toFixed(2)} | Blockchain cost: ${finalBlockchainCost.toFixed(2)}`);
            }

            // Add axis labels
            svg.append('text').attr('class', 'axis-label').attr('x', width / 2).attr('y', height + 60).text('Week');
            svg.append('text').attr('class', 'axis-label').attr('transform', 'rotate(-90)').attr('x', -height / 2).attr('y', -60).text('Total Supply Chain Cost');
        }

        function calculateCumulative(data) {
            if (!data || !data.retailer) return [];
            
            const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
            const weeks = data.retailer.length;
            const cumulativeCosts = [];
            
            let cumulativeCost = 0;
            
            for (let weekIndex = 0; weekIndex < weeks; weekIndex++) {
                let weekTotalCost = 0;
                
                // Sum the costs for all roles in this week
                for (const role of roles) {
                    if (data[role] && data[role][weekIndex] && data[role][weekIndex].weeklyCost !== undefined) {
                        weekTotalCost += data[role][weekIndex].weeklyCost;
                    }
                }
                
                // Add to cumulative total
                cumulativeCost += weekTotalCost;
                
                cumulativeCosts.push({
                    week: weekIndex,
                    value: cumulativeCost
                });
            }
            
            return cumulativeCosts;
        }

        function drawMainChart(chartType, targetDiv) {
            // Remove the '#' from the beginning of the selector if it exists
            const targetSelector = targetDiv.startsWith('#') ? targetDiv : '#' + targetDiv;
            const chartContainer = document.querySelector(targetSelector);
            
            if (!chartContainer) {
                console.error(`Chart container not found for selector: ${targetSelector}`);
                return;
            }
            
            chartContainer.innerHTML = '';

            const chartTitle = getChartTitle(chartType);
            const seriesData = generateSeriesData(chartType, getCurrentRoleFilter());

            if (seriesData.length === 0) {
                chartContainer.innerHTML = `<div class="no-data">No data available for ${chartTitle}</div>`;
                return;
            }

            // Find min and max for the axis
            let yMin = Infinity;
            let yMax = -Infinity;
            let xMax = 0;

            seriesData.forEach(series => {
                series.values.forEach(d => {
                    if (d.value !== null && d.value !== undefined) {
                        yMin = Math.min(yMin, d.value);
                        yMax = Math.max(yMax, d.value);
                        xMax = Math.max(xMax, d.week);
                    }
                });
            });

            // Ensure we have reasonable values if there's no data
            if (yMin === Infinity) yMin = 0;
            if (yMax === -Infinity) yMax = 100;
            
            // Add some padding to the y-axis, especially at the bottom
            const yRange = yMax - yMin;
            yMin = Math.max(0, yMin - yRange * 0.15); // Increased padding from 0.1 to 0.15
            yMax = yMax + yRange * 0.15; // Increased padding from 0.1 to 0.15

            // Set up dimensions
            const margin = { top: 40, right: 150, bottom: 60, left: 80 };
            const width = Math.max(800, chartContainer.offsetWidth) - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            // Create SVG
            const svg = d3.select(`#${targetDiv}`)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .style('overflow', 'visible')
                .append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -margin.top / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(chartTitle);

            // Define scales
            const x = d3.scaleLinear()
                .domain([0, xMax])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([yMin, yMax])
                .range([height, 0]);

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0, ${height})`)
                .call(d3.axisBottom(x).ticks(Math.min(xMax, 10)));

            svg.append('g')
                .call(d3.axisLeft(y));

            // Add axis labels
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 20)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .text(getYAxisLabel(chartType));

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .text('Week');

            // Create tooltip div
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("background-color", "white")
                .style("border", "1px solid #ddd")
                .style("border-radius", "5px")
                .style("padding", "10px")
                .style("pointer-events", "none");

            // Color scale
            const color = d3.scaleOrdinal(d3.schemeCategory10);

            // Lines
            seriesData.forEach((series, i) => {
                if (series.values && series.values.length > 0) {
                    // Sort values by week to ensure proper line drawing
                    series.values.sort((a, b) => a.week - b.week);
                    
                    // Create a line generator for valid data points
                    const line = d3.line()
                        .defined(d => d.value !== null && d.value !== undefined)
                        .x(d => x(d.week))
                        .y(d => y(d.value))
                        .curve(d3.curveLinear);
                        
                    // Filter out the undefined values to create segments
                    const validData = series.values.filter(d => d.value !== null && d.value !== undefined);
                    
                    // Draw the line segments where data is available
                    // This ensures discontinuities in the data show as actual gaps
                    const path = svg.append('path')
                        .datum(validData)
                        .attr('class', 'line')
                        .attr('d', line)
                        .style('stroke', series.color || color(i))
                        .style('fill', 'none')
                        .style('stroke-width', 2);
                        
                    // Apply dash pattern if specified
                    if (series.dashPattern) {
                        path.style('stroke-dasharray', series.dashPattern);
                    }
                    
                    // Remove data points (circles) as requested
                }
            });

            // Legend
            const legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width + 20}, 0)`);

            seriesData.forEach((series, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);
                    
                legendRow.append('line')
                    .attr('x1', 0)
                    .attr('y1', 10)
                    .attr('x2', 20)
                    .attr('y2', 10)
                    .style('stroke', series.color || color(i))
                    .style('stroke-width', 2);
                    
                // Apply dash pattern to legend line if specified
                if (series.dashPattern) {
                    legendRow.select('line')
                        .style('stroke-dasharray', series.dashPattern);
                }
                    
                legendRow.append('text')
                    .attr('x', 30)
                    .attr('y', 10)
                    .attr('dy', '.35em')
                    .style('font-size', '12px')
                    .text(series.name);
            });
        }

        function generateSeriesData(chartType, roleFilter = null) {
            const series = [];
            
            // Debug logging to understand data structure
            console.log("Blockchain Data Structure:", blockchainData);
            console.log("Traditional Data Structure:", traditionalData);
            
            if (chartType === 'inventory') {
                const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                
                roles.forEach(role => {
                    if (roleFilter && roleFilter !== 'all' && role !== roleFilter) return;
                    
                    // Traditional data series for inventory
                    if (traditionalData && traditionalData[role]) {
                        const values = traditionalData[role]
                            .map((weekData, weekIndex) => {
                                // Use inventoryEnd field for the final inventory value
                                const value = weekData?.inventoryEnd;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Traditional ${capitalizeFirstLetter(role)}`,
                            color: '#FF5555', // Red for traditional
                            values: values
                        });
                    }
                    
                    // Blockchain data series for inventory
                    if (blockchainData && blockchainData[role]) {
                        const values = blockchainData[role]
                            .map((weekData, weekIndex) => {
                                // Use inventoryEnd field for the final inventory value
                                const value = weekData?.inventoryEnd;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Blockchain ${capitalizeFirstLetter(role)}`,
                            values: values
                        });
                    }
                });
            } else if (chartType === 'orders') {
                const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                
                roles.forEach(role => {
                    if (roleFilter && roleFilter !== 'all' && role !== roleFilter) return;
                    
                    // Traditional data series for orders
                    if (traditionalData && traditionalData[role]) {
                        const values = traditionalData[role]
                            .map((weekData, weekIndex) => {
                                // Access order data 
                                const value = weekData?.order;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Traditional ${capitalizeFirstLetter(role)}`,
                            color: '#FF5555', // Red for traditional
                            values: values
                        });
                    }
                    
                    // Blockchain data series for orders
                    if (blockchainData && blockchainData[role]) {
                        const values = blockchainData[role]
                            .map((weekData, weekIndex) => {
                                // Access order data
                                const value = weekData?.order;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Blockchain ${capitalizeFirstLetter(role)}`,
                            values: values
                        });
                    }
                });
            } else if (chartType === 'backlog') {
                const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                
                roles.forEach(role => {
                    if (roleFilter && roleFilter !== 'all' && role !== roleFilter) return;
                    
                    // Traditional data series for backlog
                    if (traditionalData && traditionalData[role]) {
                        const values = traditionalData[role]
                            .map((weekData, weekIndex) => {
                                // Access backlog data (use backlogEnd for final state)
                                const value = weekData?.backlogEnd;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Traditional ${capitalizeFirstLetter(role)}`,
                            color: '#FF5555', // Red for traditional
                            values: values
                        });
                    }
                    
                    // Blockchain data series for backlog
                    if (blockchainData && blockchainData[role]) {
                        const values = blockchainData[role]
                            .map((weekData, weekIndex) => {
                                // Access backlog data (use backlogEnd for final state)
                                const value = weekData?.backlogEnd;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Blockchain ${capitalizeFirstLetter(role)}`,
                            values: values
                        });
                    }
                });
            } else if (chartType === 'costs') {
                const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                
                roles.forEach(role => {
                    if (roleFilter && roleFilter !== 'all' && role !== roleFilter) return;
                    
                    // Traditional data series for costs
                    if (traditionalData && traditionalData[role]) {
                        const values = traditionalData[role]
                            .map((weekData, weekIndex) => {
                                // Access weekly cost data
                                const value = weekData?.weeklyCost;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Traditional ${capitalizeFirstLetter(role)}`,
                            color: '#FF5555', // Red for traditional
                            values: values
                        });
                    }
                    
                    // Blockchain data series for costs
                    if (blockchainData && blockchainData[role]) {
                        const values = blockchainData[role]
                            .map((weekData, weekIndex) => {
                                // Access weekly cost data
                                const value = weekData?.weeklyCost;
                                // Return all points, preserving null values to show discontinuities
                                return { week: weekIndex, value: value };
                            });
                        
                        series.push({
                            name: `Blockchain ${capitalizeFirstLetter(role)}`,
                            values: values
                        });
                    }
                });
            }
            
            return series;
        }

        function getYAxisLabel(chartType) {
            const roleFilter = d3.select('#roleSelect').property('value');
            switch(chartType) {
                case 'orders': return (roleFilter === 'factory') ? 'Production Quantity' : 'Order Quantity';
                case 'inventory': return 'Inventory Level';
                case 'backlog': return 'Backlog Quantity';
                case 'costs': return 'Weekly Cost';
                default: return 'Value';
            }
        }

        function capitalizeFirstLetter(string) {
            if (!string) return '';
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // Update simulation settings based on the loaded dataset
        function updateSimulationSettings(datasetKey, blockchainData, traditionalData) {
            // Set simulation type
            let simType = '';
            if (datasetKey.includes('hybrid')) {
                simType = 'Hybrid';
                if (datasetKey.includes('triple')) {
                    simType = 'Triple Hybrid (1 Algorithmic Player)';
                } else if (datasetKey.includes('extended')) {
                    simType = 'Extended Hybrid (2 Algorithmic Players)';
                } else {
                    simType = 'Hybrid (3 Algorithmic Players)';
                }
            } else if (datasetKey.includes('crocs') || datasetKey.includes('forecasted')) {
                simType = 'Full Algorithmic (4 Algorithmic Players)';
            } else if (datasetKey.includes('random')) {
                simType = 'Random Demand Pattern';
            }
            document.getElementById('simType').textContent = simType;
            
            // Set periods
            let periods = 23; // Default
            if (datasetKey.includes('30')) {
                periods = 30;
            } else if (datasetKey.includes('forecasted')) {
                periods = 52; // Forecasted data has 52 periods
            } else if (blockchainData && blockchainData.retailer) {
                periods = blockchainData.retailer.length;
            }
            document.getElementById('simPeriods').textContent = periods;
            
            // Set delay pattern
            let delayPattern = 'Standard (1 week order + 1 week shipping)';
            if (datasetKey.includes('zero_delay')) {
                delayPattern = 'Zero Order Delay (0 week order + 1 week shipping)';
            } else if (datasetKey.includes('one_two_delay')) {
                delayPattern = 'One Week Order + Two Week Ship Delay (1 week order + 2 week shipping)';
            } else if (datasetKey.includes('two_one_delay')) {
                delayPattern = 'Two Week Order + One Week Ship Delay (2 week order + 1 week shipping)';
            } else if (datasetKey.includes('two_week_delay')) {
                delayPattern = 'Two Week Ship Delay (0 week order + 2 week shipping)';
            }
            document.getElementById('delayPattern').textContent = delayPattern;
            
            // Set initial conditions if data is available
            if (blockchainData && blockchainData.retailer && blockchainData.retailer.length > 0) {
                // Get initial inventory values for all roles
                const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                let inventoryStr = '';
                let backlogStr = '';
                
                roles.forEach(role => {
                    if (blockchainData[role] && blockchainData[role].length > 0) {
                        const initialInventory = blockchainData[role][0].inventory || 0;
                        const initialBacklog = blockchainData[role][0].backlog || 0;
                        
                        inventoryStr += `${capitalizeFirstLetter(role)}: ${initialInventory} units`;
                        backlogStr += `${capitalizeFirstLetter(role)}: ${initialBacklog} units`;
                        
                        if (role !== 'factory') {
                            inventoryStr += ', ';
                            backlogStr += ', ';
                        }
                    }
                });
                
                document.getElementById('initialInventory').textContent = inventoryStr || 'Not specified';
                document.getElementById('initialBacklog').textContent = backlogStr || '0 (All roles)';
                
                // Extract safety stock parameter if available
                let safetyStockStr = 'Default (varies by role)';
                if (blockchainData && blockchainData.retailer && blockchainData.retailer.length > 0) {
                    const roles = ['retailer', 'wholesaler', 'distributor', 'factory'];
                    let hasFoundSafetyStock = false;
                    let safetyValues = [];
                    
                    roles.forEach(role => {
                        if (blockchainData[role] && blockchainData[role].length > 0 && 
                            blockchainData[role][0].debugInfo && 
                            blockchainData[role][0].debugInfo.safetyStock !== undefined) {
                            
                            hasFoundSafetyStock = true;
                            safetyValues.push(`${capitalizeFirstLetter(role)}: ${blockchainData[role][0].debugInfo.safetyStock} units`);
                        }
                    });
                    
                    if (hasFoundSafetyStock) {
                        safetyStockStr = safetyValues.join(', ');
                    }
                }
                document.getElementById('safetyStock').textContent = safetyStockStr;
            }
            
            // Set scenario difference based on dataset type
            let scenarioDiff = 'In the <strong>Blockchain</strong> scenario, upstream players have visibility into end-customer demand and downstream inventory positions. In the <strong>Traditional</strong> scenario, players only see orders from their immediate downstream partner.';
            
            // Set ordering policy information
            let orderingPolicy = 'Base-stock policy with demand forecasting';
            
            // Try to extract alpha value from debug info if available
            let alphaValue = '';
            if (blockchainData && blockchainData.retailer && blockchainData.retailer.length > 0 && 
                blockchainData.retailer[0].debugInfo && blockchainData.retailer[0].debugInfo.alpha) {
                alphaValue = ` (α = ${blockchainData.retailer[0].debugInfo.alpha})`;
            } else if (datasetKey.includes('alpha_') && blockchainData && blockchainData.info && blockchainData.info.alpha) {
                alphaValue = ` (α = ${blockchainData.info.alpha})`;
            } else {
                // Check if we can find alpha in filename
                const alphaMatch = datasetKey.match(/alpha_(\d+\.\d+)/);
                if (alphaMatch && alphaMatch[1]) {
                    alphaValue = ` (α = ${alphaMatch[1]})`;
                } else {
                    // Default value if we can't find it
                    alphaValue = ' (α = 0.3)';
                }
            }
            
            if (datasetKey.includes('hybrid')) {
                if (datasetKey.includes('triple')) {
                    orderingPolicy = `Factory: Base-stock policy${alphaValue}; Others: Fixed historical orders`;
                } else if (datasetKey.includes('extended')) {
                    orderingPolicy = `Distributor, Factory: Base-stock policy${alphaValue}; Others: Fixed historical orders`;
                } else {
                    orderingPolicy = `Wholesaler, Distributor, Factory: Base-stock policy${alphaValue}; Retailer: Fixed historical orders`;
                }
            } else if (datasetKey.includes('crocs') || datasetKey.includes('forecasted')) {
                orderingPolicy = `All players: Base-stock policy with demand forecasting${alphaValue}`;
            }
            document.getElementById('orderingPolicy').textContent = orderingPolicy;
            
            if (datasetKey.includes('hybrid')) {
                if (datasetKey.includes('triple')) {
                    scenarioDiff = 'Only the Factory uses an algorithmic ordering policy. In the <strong>Blockchain</strong> scenario, the Factory has visibility into end-customer demand and inventory positions. In the <strong>Traditional</strong> scenario, the Factory only sees orders from the Distributor.';
                } else if (datasetKey.includes('extended')) {
                    scenarioDiff = 'Only the Distributor and Factory use algorithmic ordering policies. In the <strong>Blockchain</strong> scenario, these players have visibility into end-customer demand and inventory positions. In the <strong>Traditional</strong> scenario, players only see orders from their immediate downstream partner.';
                } else {
                    scenarioDiff = 'The Retailer uses fixed order quantities from historical data. In the <strong>Blockchain</strong> scenario, upstream players using algorithms have visibility into end-customer demand and inventory positions. In the <strong>Traditional</strong> scenario, players only see orders from their immediate downstream partner.';
                }
            }
            
            document.getElementById('scenarioDifference').innerHTML = scenarioDiff;
        }

        // Add this new function to handle alpha tuning data loading and visualization
        function loadAlphaTuningData() {
            // Load the alpha tuning JSON data
            d3.json('./alpha_tuning_results.json').then(function(data) {
                console.log("Successfully loaded alpha tuning data:", data);
                
                // Hide loading indicator, show content
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('visualization-content').style.display = 'block';
                document.getElementById('alphaTuningContainer').style.display = 'block';
                
                // Main charts should be hidden
                document.querySelectorAll('.main-charts-grid, #costComparison').forEach(el => {
                    el.style.display = 'none';
                });
                
                // Update timestamp
                updateDataTimestamp();
                
                // Create visualizations
                createAlphaHeatmap(data);
                createAlphaCostChart(data);
                createThresholdCostChart(data);
                populateAlphaTable(data);
                
            }).catch(function(error) {
                console.error('Error loading alpha tuning data:', error);
                // Hide loading, show error
                document.getElementById('loadingIndicator').style.display = 'none';
                document.getElementById('errorContainer').style.display = 'block';
                document.getElementById('errorMessage').textContent = 
                    'Error loading alpha tuning data: ' + error.message;
            });
        }
        
        function createAlphaHeatmap(data) {
            // Clear previous chart
            d3.select('#alphaTuningHeatmap').html("");
            
            // Get unique threshold and alpha values
            const thresholds = Array.from(new Set(data.map(d => d.thresholdHigh))).sort((a, b) => a - b);
            const alphas = Array.from(new Set(data.map(d => d.minAlpha))).sort((a, b) => a - b);
            
            // Create a 2D grid for heatmap
            const costGrid = [];
            for (let i = 0; i < thresholds.length; i++) {
                const row = [];
                for (let j = 0; j < alphas.length; j++) {
                    const matchingData = data.find(d => 
                        d.thresholdHigh === thresholds[i] && d.minAlpha === alphas[j]
                    );
                    row.push(matchingData ? matchingData.totalCost : null);
                }
                costGrid.push(row);
            }
            
            // Find min and max for color scale
            const allCosts = data.map(d => d.totalCost);
            const minCost = Math.min(...allCosts);
            const maxCost = Math.max(...allCosts);
            
            // Set up dimensions
            const margin = { top: 50, right: 50, bottom: 70, left: 70 };
            const width = 500 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select('#alphaTuningHeatmap')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const xScale = d3.scaleBand()
                .domain(alphas.map(String))
                .range([0, width])
                .padding(0.05);
                
            const yScale = d3.scaleBand()
                .domain(thresholds.map(String))
                .range([0, height])
                .padding(0.05);
            
            // Color scale - use a diverging scale to highlight differences
            const colorScale = d3.scaleSequential()
                .domain([maxCost, minCost])  // Reversed domain (max to min) to make low costs green
                .interpolator(d3.interpolateRdYlGn);  // Lower costs are green (better)
            
            // Add heatmap cells
            thresholds.forEach((threshold, i) => {
                alphas.forEach((alpha, j) => {
                    const cost = costGrid[i][j];
                    
                    // Add rectangle for each cell
                    svg.append('rect')
                        .attr('x', xScale(alpha.toString()))
                        .attr('y', yScale(threshold.toString()))
                        .attr('width', xScale.bandwidth())
                        .attr('height', yScale.bandwidth())
                        .style('fill', cost ? colorScale(cost) : '#ccc')
                        .attr('stroke', 'white')
                        .attr('stroke-width', 1)
                        .on('mouseover', function(event) {
                            // Add tooltip on hover
                            d3.select(this).style('opacity', 0.8);
                            d3.select('#alphaTuningHeatmap')
                                .append('div')
                                .attr('class', 'tooltip')
                                .style('position', 'absolute')
                                .style('background', 'black')
                                .style('color', 'white')
                                .style('padding', '5px')
                                .style('border-radius', '5px')
                                .style('left', (event.pageX + 10) + 'px')
                                .style('top', (event.pageY - 28) + 'px')
                                .html(`Threshold: ${threshold}<br>Alpha: ${alpha}<br>Cost: ${cost}`);
                        })
                        .on('mouseout', function() {
                            d3.select(this).style('opacity', 1);
                            d3.select('#alphaTuningHeatmap .tooltip').remove();
                        });
                    
                    // Add text for cell value
                    svg.append('text')
                        .attr('x', xScale(alpha.toString()) + xScale.bandwidth() / 2)
                        .attr('y', yScale(threshold.toString()) + yScale.bandwidth() / 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('font-size', '10px')
                        .style('fill', 'white')
                        .text(cost);
                });
            });
            
            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
                
            svg.append('g')
                .call(d3.axisLeft(yScale));
            
            // Add axis labels
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .text('Min Alpha Value');
                
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -margin.left + 20)
                .text('Threshold High Value');
                
            // Add title
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', -20)
                .style('font-size', '14px')
                .text('Total Cost by Alpha and Threshold Values');
        }
        
        function createAlphaCostChart(data) {
            // Clear previous chart
            d3.select('#alphaCostChart').html("");
            
            // Get unique alpha values
            const alphas = Array.from(new Set(data.map(d => d.minAlpha))).sort((a, b) => a - b);
            
            // Aggregate data by alpha values
            const alphaData = alphas.map(alpha => {
                const matchingEntries = data.filter(d => d.minAlpha === alpha);
                const avgCost = d3.mean(matchingEntries, d => d.totalCost);
                const minCost = d3.min(matchingEntries, d => d.totalCost);
                const maxCost = d3.max(matchingEntries, d => d.totalCost);
                
                return {
                    alpha: alpha,
                    avgCost: avgCost,
                    minCost: minCost,
                    maxCost: maxCost
                };
            });
            
            // Set up dimensions
            const margin = { top: 50, right: 50, bottom: 70, left: 70 };
            const width = 500 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select('#alphaCostChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const xScale = d3.scaleBand()
                .domain(alphas.map(a => a.toString()))
                .range([0, width])
                .padding(0.3);
                
            const yScale = d3.scaleLinear()
                .domain([
                    d3.min(alphaData, d => d.minCost) * 0.998, 
                    d3.max(alphaData, d => d.maxCost) * 1.002
                ])
                .range([height, 0]);
            
            // Add bars
            svg.selectAll('.bar')
                .data(alphaData)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.alpha.toString()))
                .attr('y', d => yScale(d.avgCost))
                .attr('width', xScale.bandwidth())
                .attr('height', d => height - yScale(d.avgCost))
                .attr('fill', 'steelblue');
                
            // Add error bars (min to max range)
            svg.selectAll('.error-line')
                .data(alphaData)
                .enter()
                .append('line')
                .attr('class', 'error-line')
                .attr('x1', d => xScale(d.alpha.toString()) + xScale.bandwidth() / 2)
                .attr('x2', d => xScale(d.alpha.toString()) + xScale.bandwidth() / 2)
                .attr('y1', d => yScale(d.minCost))
                .attr('y2', d => yScale(d.maxCost))
                .attr('stroke', 'black')
                .attr('stroke-width', 1.5);
                
            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale));
                
            svg.append('g')
                .call(d3.axisLeft(yScale));
            
            // Add axis labels
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .text('Alpha Value');
                
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -margin.left + 20)
                .text('Total Cost');
                
            // Add title
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', -20)
                .style('font-size', '14px')
                .text('Effect of Alpha Value on Total Cost');
        }
        
        function createThresholdCostChart(data) {
            // Clear previous chart
            d3.select('#thresholdCostChart').html("");
            
            // Get unique threshold values
            const thresholds = Array.from(new Set(data.map(d => d.thresholdHigh))).sort((a, b) => a - b);
            
            // Aggregate data by threshold values
            const thresholdData = thresholds.map(threshold => {
                const matchingEntries = data.filter(d => d.thresholdHigh === threshold);
                const avgCost = d3.mean(matchingEntries, d => d.totalCost);
                const minCost = d3.min(matchingEntries, d => d.totalCost);
                const maxCost = d3.max(matchingEntries, d => d.totalCost);
                
                return {
                    threshold: threshold,
                    avgCost: avgCost,
                    minCost: minCost,
                    maxCost: maxCost
                };
            });
            
            // Set up dimensions
            const margin = { top: 50, right: 50, bottom: 70, left: 70 };
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select('#thresholdCostChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const xScale = d3.scaleBand()
                .domain(thresholds.map(t => t.toString()))
                .range([0, width])
                .padding(0.3);
                
            const yScale = d3.scaleLinear()
                .domain([
                    d3.min(thresholdData, d => d.minCost) * 0.998, 
                    d3.max(thresholdData, d => d.maxCost) * 1.002
                ])
                .range([height, 0]);
            
            // Add bars
            svg.selectAll('.bar')
                .data(thresholdData)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.threshold.toString()))
                .attr('y', d => yScale(d.avgCost))
                .attr('width', xScale.bandwidth())
                .attr('height', d => height - yScale(d.avgCost))
                .attr('fill', 'teal');
                
            // Add error bars (min to max range)
            svg.selectAll('.error-line')
                .data(thresholdData)
                .enter()
                .append('line')
                .attr('class', 'error-line')
                .attr('x1', d => xScale(d.threshold.toString()) + xScale.bandwidth() / 2)
                .attr('x2', d => xScale(d.threshold.toString()) + xScale.bandwidth() / 2)
                .attr('y1', d => yScale(d.minCost))
                .attr('y2', d => yScale(d.maxCost))
                .attr('stroke', 'black')
                .attr('stroke-width', 1.5);
                
            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale));
                
            svg.append('g')
                .call(d3.axisLeft(yScale));
            
            // Add axis labels
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .text('Threshold High Value');
                
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -margin.left + 20)
                .text('Total Cost');
                
            // Add title
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', -20)
                .style('font-size', '14px')
                .text('Effect of Threshold Value on Total Cost');
        }
        
        function populateAlphaTable(data) {
            // Sort data by total cost (ascending)
            const sortedData = [...data].sort((a, b) => a.totalCost - b.totalCost);
            
            // Get the table body
            const tableBody = document.getElementById('alphaTuningTableBody');
            tableBody.innerHTML = '';
            
            // Find min cost for highlighting
            const minCost = Math.min(...data.map(d => d.totalCost));
            
            // Add rows to the table
            sortedData.forEach(item => {
                const row = document.createElement('tr');
                
                // Highlight best values
                if (item.totalCost === minCost) {
                    row.style.backgroundColor = '#e6ffe6';
                    row.style.fontWeight = 'bold';
                }
                
                // Add cells
                row.innerHTML = `
                    <td style="padding: 8px; border: 1px solid #ddd;">${item.thresholdHigh}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${item.minAlpha}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${item.totalCost}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }
    </script>
</body>
</html> 