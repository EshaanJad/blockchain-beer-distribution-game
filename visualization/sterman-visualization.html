<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sterman Model Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: #333;
        }
        .visualization-section {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .chart-container {
            margin-top: 20px;
            height: 400px;
            width: 100%;
        }
        .scenario-select {
            margin: 10px 0;
            padding: 10px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f2f2f2;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .nav-links {
            margin-bottom: 20px;
        }
        .nav-links a {
            margin-right: 15px;
            color: #0066cc;
            text-decoration: none;
        }
        .nav-links a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="visualization.html">Original Visualization</a>
        </div>
        
        <h1>Sterman Model Simulation Results</h1>
        
        <div class="visualization-section">
            <h2>Select Simulation Type</h2>
            <select id="simulationTypeSelect" class="scenario-select">
                <option value="standard">Standard Sterman Model</option>
                <option value="two-order-delay">Two-Order Delay Model</option>
                <option value="two-shipping-delay">Two-Shipping Delay Model</option>
                <option value="zero-delay">Zero Delay Model</option>
                <option value="hybrid-retailer">Hybrid Retailer Model</option>
                <option value="hybrid-retailer-wholesaler">Hybrid Retailer-Wholesaler Model</option>
            </select>
            
            <div class="simulation-summary">
                <h3>Simulation Summary</h3>
                <div id="summaryContainer"></div>
            </div>
        </div>

        <div class="visualization-section">
            <h2>Orders Placed by Role (Traditional)</h2>
            <div id="ordersChartTraditional" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Orders Placed by Role (Blockchain)</h2>
            <div id="ordersChartBlockchain" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Inventory Levels by Role (Traditional)</h2>
            <div id="inventoryChartTraditional" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Inventory Levels by Role (Blockchain)</h2>
            <div id="inventoryChartBlockchain" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Backlog Levels by Role (Traditional)</h2>
            <div id="backlogChartTraditional" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Backlog Levels by Role (Blockchain)</h2>
            <div id="backlogChartBlockchain" class="chart-container"></div>
        </div>

        <div class="visualization-section">
            <h2>Weekly Costs</h2>
            <div id="costsChart" class="chart-container"></div>
        </div>
    </div>

    <script>
        // Simulation data paths
        const dataPaths = {
            'standard': {
                blockchain: 'data/simulations/sterman/single/blockchain.json',
                traditional: 'data/simulations/sterman/single/traditional.json',
                settings: {
                    description: 'Standard Sterman Model',
                    orderDelay: 1,
                    shippingDelay: 1,
                    blockchainEnabled: false,
                    hybridRoles: []
                }
            },
            'two-order-delay': {
                blockchain: 'data/simulations/sterman/two-order-delay/blockchain.json',
                traditional: 'data/simulations/sterman/two-order-delay/traditional.json',
                settings: {
                    description: 'Two-Order Delay Model',
                    orderDelay: 2,
                    shippingDelay: 1,
                    blockchainEnabled: false,
                    hybridRoles: []
                }
            },
            'hybrid-retailer': {
                blockchain: 'data/simulations/sterman/hybrid-retailer/blockchain.json',
                traditional: 'data/simulations/sterman/hybrid-retailer/traditional.json',
                settings: {
                    description: 'Hybrid Retailer Model',
                    orderDelay: 1,
                    shippingDelay: 1,
                    blockchainEnabled: true,
                    hybridRoles: ['Retailer']
                }
            },
            'two-shipping-delay': {
                blockchain: 'data/simulations/sterman/two-shipping-delay/blockchain.json',
                traditional: 'data/simulations/sterman/two-shipping-delay/traditional.json',
                settings: {
                    description: 'Two-Shipping Delay Model',
                    orderDelay: 1,
                    shippingDelay: 2,
                    blockchainEnabled: false,
                    hybridRoles: []
                }
            },
            'zero-delay': {
                blockchain: 'data/simulations/sterman/zero-delay/blockchain.json',
                traditional: 'data/simulations/sterman/zero-delay/traditional.json',
                settings: {
                    description: 'Zero Delay Model',
                    orderDelay: 0,
                    shippingDelay: 1,
                    blockchainEnabled: false,
                    hybridRoles: []
                }
            },
            'hybrid-retailer-wholesaler': {
                blockchain: 'data/simulations/sterman/hybrid-retailer-wholesaler/blockchain.json',
                traditional: 'data/simulations/sterman/hybrid-retailer-wholesaler/traditional.json',
                settings: {
                    description: 'Hybrid Retailer-Wholesaler Model',
                    orderDelay: 1,
                    shippingDelay: 1,
                    blockchainEnabled: true,
                    hybridRoles: ['Retailer', 'Wholesaler']
                }
            }
        };

        // Role names and colors for visualization
        const roles = [
            { id: 0, name: 'Retailer', color: '#1f77b4' },
            { id: 1, name: 'Wholesaler', color: '#ff7f0e' },
            { id: 2, name: 'Distributor', color: '#2ca02c' },
            { id: 3, name: 'Factory', color: '#d62728' }
        ];

        // Load and display simulation data
        let blockchainData, traditionalData, summaryData;
        let currentSimulationType = 'standard'; // Default simulation type
        
        // Function to load simulation data
        function loadSimulationData(simulationType) {
            currentSimulationType = simulationType;
            const paths = dataPaths[simulationType];
            
            // Load blockchain data
            d3.json(paths.blockchain).then(data => {
                blockchainData = data;
                if (traditionalData) {
                    renderCharts(blockchainData, traditionalData);
                    // Generate summary data from JSON files
                    calculateAndRenderSummary(blockchainData, traditionalData, simulationType);
                }
            }).catch(error => console.error("Error loading blockchain data:", error));
            
            // Load traditional data
            d3.json(paths.traditional).then(data => {
                traditionalData = data;
                if (blockchainData) {
                    renderCharts(blockchainData, traditionalData);
                    // Generate summary data from JSON files
                    calculateAndRenderSummary(blockchainData, traditionalData, simulationType);
                }
            }).catch(error => console.error("Error loading traditional data:", error));
        }
        
        // Calculate summary from JSON data
        function calculateAndRenderSummary(blockchainData, traditionalData, simulationType) {
            if (!blockchainData || !traditionalData) return;
            
            // Get the last week's cumulative cost for the total cost
            const traditionalTotalCost = traditionalData[traditionalData.length - 1].cumulativeCost.reduce((sum, cost) => sum + cost, 0);
            const blockchainTotalCost = blockchainData[blockchainData.length - 1].cumulativeCost.reduce((sum, cost) => sum + cost, 0);
            
            // Calculate cost reduction
            const costReduction = traditionalTotalCost - blockchainTotalCost;
            const costReductionPercent = ((costReduction / traditionalTotalCost) * 100).toFixed(2);
            
            // Create summary object
            const summary = {
                Periods: blockchainData.length,
                TraditionalCost: traditionalTotalCost.toFixed(2),
                BlockchainCost: blockchainTotalCost.toFixed(2),
                CostReduction: costReduction.toFixed(2),
                CostReductionPercent: costReductionPercent,
                settings: dataPaths[simulationType].settings
            };
            
            // Render the summary
            renderSummary(summary, simulationType);
        }
        
        // Render charts for orders, inventory, and costs
        function renderCharts(blockchainData, traditionalData) {
            if (!blockchainData || !traditionalData) {
                console.error("Cannot render charts: data is not available");
                return;
            }
            
            // Render traditional data charts
            renderOrdersChartTraditional(traditionalData);
            renderInventoryChartTraditional(traditionalData);
            renderBacklogChartTraditional(traditionalData);
            
            // Render blockchain data charts
            renderOrdersChartBlockchain(blockchainData);
            renderInventoryChartBlockchain(blockchainData);
            renderBacklogChartBlockchain(blockchainData);
            
            // Render comparison chart
            renderCostsChart(blockchainData, traditionalData);
        }
        
        // Render simulation summary
        function renderSummary(summary, simulationType) {
            if (!summary) return;
            
            const container = document.getElementById('summaryContainer');
            const settings = dataPaths[simulationType].settings;
            
            // Clear container
            container.innerHTML = '';
            
            // Add settings information
            const settingsDiv = document.createElement('div');
            settingsDiv.className = 'simulation-settings';
            settingsDiv.style.marginBottom = '20px';
            
            settingsDiv.innerHTML = `
                <h4>Simulation Settings</h4>
                <table class="comparison-table">
                    <tbody>
                        <tr>
                            <td><strong>Description:</strong></td>
                            <td>${settings.description}</td>
                        </tr>
                        <tr>
                            <td><strong>Order Delay:</strong></td>
                            <td>${settings.orderDelay} ${settings.orderDelay === 1 ? 'week' : 'weeks'}</td>
                        </tr>
                        <tr>
                            <td><strong>Shipping Delay:</strong></td>
                            <td>${settings.shippingDelay} ${settings.shippingDelay === 1 ? 'week' : 'weeks'}</td>
                        </tr>
                        <tr>
                            <td><strong>Hybrid Roles:</strong></td>
                            <td>${settings.hybridRoles.length > 0 ? settings.hybridRoles.join(', ') : 'None'}</td>
                        </tr>
                    </tbody>
                </table>
            `;
            container.appendChild(settingsDiv);
            
            // Create results table
            const table = document.createElement('table');
            table.className = 'comparison-table';
            
            // Create table header
            const tableHeader = document.createElement('thead');
            tableHeader.innerHTML = `
                <tr>
                    <th>Periods</th>
                    <th>Traditional Cost</th>
                    <th>Blockchain Cost</th>
                    <th>Cost Reduction</th>
                    <th>Cost Reduction %</th>
                </tr>
            `;
            table.appendChild(tableHeader);
            
            // Create table body
            const tableBody = document.createElement('tbody');
            tableBody.innerHTML = `
                <tr>
                    <td>${summary.Periods}</td>
                    <td>${summary.TraditionalCost}</td>
                    <td>${summary.BlockchainCost}</td>
                    <td>${summary.CostReduction}</td>
                    <td>${summary.CostReductionPercent}%</td>
                </tr>
            `;
            table.appendChild(tableBody);
            
            // Add results table to container
            container.appendChild(table);
        }
        
        // Render orders chart for traditional data
        function renderOrdersChartTraditional(data) {
            const container = document.getElementById('ordersChartTraditional');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#ordersChartTraditional')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => {
                    return d3.max(d.orders);
                }) * 1.2])
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Orders');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const ordersData = data.map(d => d.orders[role.id]);
                
                svg.append('path')
                    .datum(ordersData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Customer demand is typically constant at 4 per week
            const customerDemandData = data.map(d => 4);
            
            svg.append('path')
                .datum(customerDemandData)
                .attr('fill', 'none')
                .attr('stroke', '#9467bd')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('d', line);
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data([...roles, {name: 'Customer Demand', color: '#9467bd'}])
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render orders chart for blockchain data
        function renderOrdersChartBlockchain(data) {
            const container = document.getElementById('ordersChartBlockchain');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#ordersChartBlockchain')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => {
                    return d3.max(d.orders);
                }) * 1.2])
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Orders');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const ordersData = data.map(d => d.orders[role.id]);
                
                svg.append('path')
                    .datum(ordersData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Customer demand is typically constant at 4 per week
            const customerDemandData = data.map(d => 4);
            
            svg.append('path')
                .datum(customerDemandData)
                .attr('fill', 'none')
                .attr('stroke', '#9467bd')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('d', line);
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data([...roles, {name: 'Customer Demand', color: '#9467bd'}])
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render inventory chart for traditional data
        function renderInventoryChartTraditional(data) {
            const container = document.getElementById('inventoryChartTraditional');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#inventoryChartTraditional')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Find min/max values for y-axis scale
            const allInventoryValues = data.flatMap(d => d.inventory);
            
            const minValue = d3.min(allInventoryValues);
            const maxValue = d3.max(allInventoryValues);
            const yDomain = [
                minValue < 0 ? minValue * 1.2 : 0, 
                maxValue * 1.2
            ];
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain(yDomain)
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Inventory');
            
            // Add zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('y1', y(0))
                .attr('x2', width)
                .attr('y2', y(0))
                .attr('stroke', '#999')
                .attr('stroke-dasharray', '3,3');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const inventoryData = data.map(d => d.inventory[role.id]);
                
                svg.append('path')
                    .datum(inventoryData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data(roles)
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render inventory chart for blockchain data
        function renderInventoryChartBlockchain(data) {
            const container = document.getElementById('inventoryChartBlockchain');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#inventoryChartBlockchain')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Find min/max values for y-axis scale
            const allInventoryValues = data.flatMap(d => d.inventory);
            
            const minValue = d3.min(allInventoryValues);
            const maxValue = d3.max(allInventoryValues);
            const yDomain = [
                minValue < 0 ? minValue * 1.2 : 0, 
                maxValue * 1.2
            ];
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain(yDomain)
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Inventory');
            
            // Add zero line
            svg.append('line')
                .attr('x1', 0)
                .attr('y1', y(0))
                .attr('x2', width)
                .attr('y2', y(0))
                .attr('stroke', '#999')
                .attr('stroke-dasharray', '3,3');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const inventoryData = data.map(d => d.inventory[role.id]);
                
                svg.append('path')
                    .datum(inventoryData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data(roles)
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render backlog chart for traditional data
        function renderBacklogChartTraditional(data) {
            const container = document.getElementById('backlogChartTraditional');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#backlogChartTraditional')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Find max value for y-axis scale
            const allBacklogValues = data.flatMap(d => d.backlog);
            const maxValue = d3.max(allBacklogValues);
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, maxValue * 1.2 || 1]) // Ensure non-zero domain even if all backlogs are 0
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Backlog');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const backlogData = data.map(d => d.backlog[role.id]);
                
                svg.append('path')
                    .datum(backlogData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data(roles)
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render backlog chart for blockchain data
        function renderBacklogChartBlockchain(data) {
            const container = document.getElementById('backlogChartBlockchain');
            container.innerHTML = '';
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#backlogChartBlockchain')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Find max value for y-axis scale
            const allBacklogValues = data.flatMap(d => d.backlog);
            const maxValue = d3.max(allBacklogValues);
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, maxValue * 1.2 || 1]) // Ensure non-zero domain even if all backlogs are 0
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Backlog');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw lines for each role
            roles.forEach(role => {
                const backlogData = data.map(d => d.backlog[role.id]);
                
                svg.append('path')
                    .datum(backlogData)
                    .attr('fill', 'none')
                    .attr('stroke', role.color)
                    .attr('stroke-width', 2)
                    .attr('d', line);
            });
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data(roles)
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Render costs chart
        function renderCostsChart(blockchainData, traditionalData) {
            const container = document.getElementById('costsChart');
            container.innerHTML = '';
            
            // Check if data exists
            if (!blockchainData || !traditionalData) {
                container.innerHTML = '<p>Cost data not available</p>';
                return;
            }
            
            // Set up SVG
            const margin = {top: 20, right: 80, bottom: 30, left: 50};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;
            
            const svg = d3.select('#costsChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Calculate total cost per week (sum of all roles)
            const blockchainWeeklyCosts = blockchainData.map(week => 
                week.cost.reduce((sum, cost) => sum + cost, 0)
            );
            
            let traditionalWeeklyCosts = [];
            if (traditionalData) {
                traditionalWeeklyCosts = traditionalData.map(week => 
                    week.cost.reduce((sum, cost) => sum + cost, 0)
                );
            }
            
            // Find the max value for y axis scaling
            const maxBlockchainCost = d3.max(blockchainWeeklyCosts);
            const maxTraditionalCost = traditionalData ? d3.max(traditionalWeeklyCosts) : 0;
            const maxCost = Math.max(maxBlockchainCost, maxTraditionalCost);
            
            // Define scales
            const x = d3.scaleLinear()
                .domain([0, blockchainData.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, maxCost * 1.2])
                .range([height, 0]);
            
            // Add X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => `Week ${d}`))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");
            
            // Add Y axis
            svg.append('g')
                .call(d3.axisLeft(y));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Costs');
            
            // Create line generator
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d));
            
            // Draw blockchain cost line if needed
            if (maxBlockchainCost > 0) {
                svg.append('path')
                    .datum(blockchainWeeklyCosts)
                    .attr('fill', 'none')
                    .attr('stroke', '#1f77b4')
                    .attr('stroke-width', 2)
                    .attr('d', line);
            }
            
            // Draw traditional cost line if needed
            if (maxTraditionalCost > 0) {
                svg.append('path')
                    .datum(traditionalWeeklyCosts)
                    .attr('fill', 'none')
                    .attr('stroke', '#d62728')
                    .attr('stroke-width', 2)
                    .attr('d', line);
            }
            
            // Create legend entries based on display mode
            const legendEntries = [];
            if (maxBlockchainCost > 0) {
                legendEntries.push({name: 'Blockchain Costs', color: '#1f77b4'});
            }
            if (maxTraditionalCost > 0) {
                legendEntries.push({name: 'Traditional Costs', color: '#d62728'});
            }
            
            // Add legend
            const legend = svg.append('g')
                .attr('font-family', 'sans-serif')
                .attr('font-size', 10)
                .attr('text-anchor', 'end')
                .selectAll('g')
                .data(legendEntries)
                .enter().append('g')
                .attr('transform', (d, i) => `translate(0,${i * 20})`);
            
            legend.append('rect')
                .attr('x', width + 20)
                .attr('width', 19)
                .attr('height', 19)
                .attr('fill', d => d.color);
            
            legend.append('text')
                .attr('x', width + 15)
                .attr('y', 9.5)
                .attr('dy', '0.32em')
                .text(d => d.name);
        }
        
        // Initialize with standard simulation
        loadSimulationData('standard');
        
        // Set up event listener for simulation type selection
        document.getElementById('simulationTypeSelect').addEventListener('change', function() {
            loadSimulationData(this.value);
        });
        
        // Add error handling message
        window.addEventListener('error', function(event) {
            console.error('Error in visualization:', event.error);
            document.getElementById('summaryContainer').innerHTML = `
                <div style="color: red; padding: 10px; border: 1px solid red; margin-top: 10px;">
                    <p>There was an error loading the visualization. Please check the browser console for details.</p>
                </div>
            `;
        });
    </script>
</body>
</html> 